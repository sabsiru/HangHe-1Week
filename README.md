# 동시성 제어 방식 및 각 방식의 장/단점

# CountDownLatch 정리

## 개요

`CountDownLatch`는 Java의 동시성 유틸리티 클래스 중 하나로, 지정된 수의 작업이 완료될 때까지 다른 쓰레드가 기다리도록 만드는 구조입니다.  
주로 다수의 쓰레드가 완료되기를 기다리거나, 테스트에서 동시에 작업을 시작시키는 용도로 사용됩니다.

---

## 원리

1. `new CountDownLatch(N)` 으로 카운트를 설정한다.
2. 작업 쓰레드들이 완료될 때마다 `countDown()`을 호출하여 카운트를 감소시킨다.
3. 메인 쓰레드는 `await()`을 호출하고, 내부 카운트가 0이 될 때까지 대기한다.
4. 카운트가 0이 되면 `await()`은 해제되고 다음 로직으로 진행된다.

---

## 장점

| 항목 | 설명 |
|------|------|
| 간단한 쓰레드 동기화 | 지정한 수의 쓰레드가 모두 완료될 때까지 기다릴 수 있다. |
| 사용법이 직관적 | `await()`, `countDown()`만으로 구성되어 사용이 간단하다. |
| 테스트에 적합 | 동시성 문제를 재현하거나 성능 테스트 시 유용하다. |
| 락이 아님 | 내부적으로는 CAS 기반으로 동작하며 일반적인 락과는 다르다. |

---

## 단점

| 항목 | 설명 |
|------|------|
| 재사용 불가 | 한 번 0이 되면 다시 사용할 수 없다. (새로 생성해야 함) |
| 블로킹 방식 | `await()`을 호출한 쓰레드는 무조건 대기한다. |
| 실제 자원 동기화는 아님 | 공유 자원의 일관성을 보장하려면 `Lock`이나 `Atomic` 등의 별도 동기화 도구가 필요하다. |
| 실수로 countDown 누락 시 문제 발생 | `await()`가 영원히 대기 상태가 될 수 있다. |

---

## 실무 사용 예시

- 여러 스레드가 동시에 특정 작업을 시작하거나 종료할 때까지 대기
- 동시성 테스트에서 요청을 동시에 발생시키는 용도
- 초기화 작업 완료를 기다리는 상황 (예: 서버 기동 시 여러 컴포넌트 준비 대기)

---

## 사용 예시 코드

```java
int threadCount = 10;
CountDownLatch latch = new CountDownLatch(threadCount);

for (int i = 0; i < threadCount; i++) {
    new Thread(() -> {
        try {
            // 동시 실행할 작업
        } finally {
            latch.countDown(); // 완료 후 카운트 감소
        }
    }).start();
}

latch.await(); // 모든 스레드가 countDown() 하기 전까지 대기
System.out.println("모든 작업 완료됨");
```
---
# ReentrantLock 정리

## 개요

`ReentrantLock`은 `java.util.concurrent.locks` 패키지에서 제공하는 명시적 락(Mutex) 구현체로,  
`synchronized` 키워드보다 더 많은 기능과 유연성을 제공하는 고급 동기화 도구입니다.  
"재진입 가능(reentrant)"하다는 것은 한 쓰레드가 이미 획득한 락을 다시 획득할 수 있다는 의미입니다.

---

## 원리

- `lock()`을 호출하면 해당 쓰레드는 락을 획득할 때까지 대기합니다.
- 락을 획득한 쓰레드는 `unlock()`을 호출하여 락을 해제해야 합니다.
- 한 쓰레드가 같은 락을 여러 번 `lock()` 할 수 있으며, 그에 따라 `unlock()`도 동일한 횟수로 호출되어야 완전히 해제됩니다.
- `tryLock()`을 사용하면 락 획득 여부를 비차단 방식으로 확인할 수 있습니다.
- `lockInterruptibly()`를 사용하면 락 대기 중 인터럽트 처리가 가능합니다.

---

## 장점

| 항목 | 설명 |
|------|------|
| 명시적 락 제어 | 언제 락을 걸고 해제할지 직접 제어할 수 있어 유연하다. |
| 재진입 가능 | 같은 쓰레드가 여러 번 락을 획득할 수 있다. |
| tryLock 지원 | 대기하지 않고 락 획득 여부를 확인할 수 있다. |
| 인터럽트 대응 가능 | `lockInterruptibly()`로 락 대기 중에도 인터럽트를 처리할 수 있다. |
| 공정성 설정 가능 | 생성자에서 `fair=true`로 설정하면 먼저 대기한 쓰레드에게 우선권을 부여할 수 있다. |

---

## 단점

| 항목 | 설명 |
|------|------|
| unlock 누락 위험 | 락 해제를 개발자가 명시적으로 해야 하므로 실수할 가능성이 있다. |
| 코드 복잡도 증가 | `try-finally` 블록이 필요하고 코드가 길어질 수 있다. |
| 과도한 락 사용 시 성능 저하 | 락이 많아지면 synchronized와 동일하게 병목이 발생할 수 있다. |

---

## 실무 사용 예시

- 동시성 제어가 필요한 비즈니스 로직 (예: 포인트 증가, 재고 감소)
- 조건에 따라 락을 유연하게 제어해야 하는 경우 (timeout, 인터럽트 등)
- `synchronized`의 기능으로는 부족할 때 (공정성, 락 분리 등)

---

## 사용 예시 코드

```java
private final Lock lock = new ReentrantLock();

public void update() {
    lock.lock();
    try {
        // 임계 구역
        // 공유 자원 변경
    } finally {
        lock.unlock(); // 꼭 해제해야 함
    }
}
```
---
### AtomicXXX

장점
•	매우 가볍고 빠름 (CAS 기반, 락 없음)
•	단일 변수의 원자적 업데이트에 가장 효율적

단점
•	복합 상태 제어 불가능 (ex. 여러 필드, 조건문 등)
•	특정 로직 흐름 제어에는 부족함

실무 사용
•	단일 카운터/포인트 증가에 자주 사용
•	분산락이나 트랜잭션 흐름에는 부적합
---
### ConcurrentMap + computeIfPresent

장점
•	Map 기반의 구조에선 훌륭한 선택
•	computeIfPresent() 로 락 없이 상태 일관성 유지

단점
•	데이터 구조가 Map 기반일 때만 적합
•	내부 처리 흐름이 추상화되어 있어 미세한 제어 어려움

실무 사용
•	캐시, 세션 등에서 빈번하게 사용
---
### synchronized

장점
•	코드가 간단하고 직관적
•	JVM이 관리하므로 안정성 높음

단점
•	블로킹 기반 → 성능 저하 가능
•	재진입 불가능 (ReentrantLock은 가능)
•	세밀한 컨트롤 어려움 (timeout, tryLock 등 불가)

실무 사용: 매우 기초적인 수준이나, 단순한 동기화에 종종 사용

---
### tampedLock
원리: 읽기/쓰기 락을 개선한 버전 + optimistic 읽기

장점
•	읽기 쓰레드 성능 우수 (낙관적 락 사용)
•	read/write 작업을 정밀하게 나눌 수 있음

단점
•	재진입 불가 (복잡한 흐름 제어 어려움)
•	사용법이 다소 까다로움 

실무 사용: CPU-bound 로직이 많고 read-heavy한 구조에서 사용됨 (ex. high-read-low-write cache)